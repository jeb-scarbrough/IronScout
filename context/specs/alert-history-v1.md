# Alert History Logging v1 (Saved Items)

**Status:** Draft (ready for implementation)  
**Owner:** Product + Engineering  
**Related Issues:** #88 (alert history page), #16 (alerts foundations)  
**Related ADRs:** ADR-005, ADR-009, ADR-011, ADR-015, ADR-020  
**Related Ops Policy:** `context/operations/alerts_policy_v1.md`

---

## 1) Purpose

Provide a **user-visible history** of alerts that were actually delivered
(price drops / back-in-stock) for Saved Items. This enables the real
`/dashboard/alerts` page to show **past alert notifications** with dates and
price change details.

This spec **does not** create a new alerting policy. It only logs and serves
events that the alert pipeline already decided to send.

---

## 1.1) Existing Implementation (Interim Hack to Replace)

**Current state (as of 2026-02):**
`apps/api/src/services/saved-items.ts:getAlertHistory()` queries
`execution_logs` for `ALERT_NOTIFY` / `ALERT_DELAYED_SENT` events and extracts
`userId` from `metadata`.

This is **not acceptable** for user-facing history:
- `execution_logs` is an operational log tied to scraper/harvester executions.
- No schema guarantees on `metadata` shape.
- No index on `metadata->>'userId'` (poor performance).
- Logs are deleted when executions are cleaned up (history vanishes).

**This spec replaces the execution_logs approach.**
Implementation must **remove** the execution_logs query path and migrate
`GET /api/saved-items/history` to the new `alert_events` table.

**Backfill policy:** No backfill from `execution_logs` (history starts clean).
If historical continuity is required later, add a one-time backfill script and
document the mapping rules separately.

---

## 2) Scope

### In Scope
- Append-only log of delivered alert events
- Minimal DB schema and migration
- API endpoint for history (`GET /api/saved-items/history`)
- Deterministic idempotency to prevent duplicate rows on retries
- UI-ready response shape (product name, event type, triggered date, price deltas)

### Out of Scope
- Building the full alert delivery pipeline
- New alert types beyond price drop + back-in-stock
- Push/SMS channels (email only in v1)
- “Undo” or retraction of sent alerts
- Alert scoring or recommendations

---

## 3) Principles & Constraints

- **Fail closed on ambiguity** (ADR-009): if the alert cannot be validated or
  delivery cannot be confirmed, **do not log** an event.
- **Visibility enforced at evaluation time** (ADR-005): only visible/eligible
  retailer inventory may trigger alerts.
- **No recommendations or verdicts** (ADR-006): history is descriptive only.
- **Saved Items only** (ADR-011 + Alerts Policy v1): no saved-search alerts.
- **Append-only log**: history rows are immutable once written.

---

## 4) Data Model

### New Table: `alert_events`

**Purpose:** Append-only log of alert notifications that were sent to a user.

| Column | Type | Required | Notes |
|---|---|---|---|
| `id` | `TEXT` | yes | CUID generated by app |
| `userId` | `TEXT` | yes | FK → `users.id` (nullable in DB to preserve history on delete; must be set on insert) |
| `watchlistItemId` | `TEXT` | yes | FK → `watchlist_items.id` (nullable in DB to preserve history on delete; must be set on insert) |
| `alertId` | `TEXT` | no | FK → `alerts.id` (optional link to rule) |
| `productId` | `TEXT` | yes | FK → `products.id` (nullable in DB to preserve history on delete; must be set on insert) |
| `retailerId` | `TEXT` | no | FK → `retailers.id` |
| `sourceId` | `TEXT` | no | FK → `sources.id` |
| `triggerPriceId` | `TEXT` | yes | FK → `prices.id` (nullable in DB to preserve history on delete; must be set on insert when available) |
| `eventType` | `TEXT` | yes | Enum: `PRICE_DROP`, `BACK_IN_STOCK` |
| `triggeredAt` | `TIMESTAMPTZ` | yes | When the event condition was detected |
| `priceAtTrigger` | `DECIMAL(10,2)` | no | Current visible price at trigger |
| `previousPrice` | `DECIMAL(10,2)` | no | Previous visible price (price drop only) |
| `currency` | `TEXT` | yes | Default `USD` |
| `deliveryChannel` | `TEXT` | yes | Enum: v1 = `EMAIL` only |
| `providerMessageId` | `TEXT` | no | Email provider id (optional) |
| `idempotencyKey` | `TEXT` | yes | Unique dedupe key (see §5) |
| `createdAt` | `TIMESTAMPTZ` | yes | Default `now()` |

**Indexes**
- `UNIQUE(idempotencyKey)`
- `INDEX(userId, triggeredAt DESC)`
- `INDEX(watchlistItemId, triggeredAt DESC)`
- `INDEX(productId, triggeredAt DESC)`

**FK behavior**
- `users` / `watchlist_items` / `products` / `prices`: `ON DELETE SET NULL`
- `retailers` / `sources` / `alerts`: `ON DELETE SET NULL`

> Rationale: history is append-only and should survive cleanup. If GDPR purge
> requires hard deletion, it must be an explicit, documented retention action,
> not an implicit FK cascade.

---

## 4.1) Retention & Orphaned Rows

Active user history has **no retention policy** in v1.

If a user is deleted and `userId` becomes NULL, those rows are **orphaned** and
no longer user-visible. Orphaned rows **must be purged after 30 days** via an
ops job (documented in runbooks), unless a legal hold requires longer.

This prevents unbounded storage growth while preserving a short audit window.

---

## 5) Idempotency Rules (Retry-Safe)

### Preferred key
```
idempotencyKey = `${watchlistItemId}:${eventType}:${triggerPriceId}`
```

This is the safest and most precise dedupe key. It guarantees that re-sends,
retries, or concurrent workers for the same triggering price do not duplicate
history rows.

### Fallback key (only if triggerPriceId is unavailable)
```
idempotencyKey = `${watchlistItemId}:${eventType}:${triggeredAtDay}`
```

**triggeredAtDay** = `YYYY-MM-DD` (UTC day).

### Insert behavior
- Always use `ON CONFLICT (idempotencyKey) DO NOTHING`.
- If insert is skipped, treat as success (history already recorded).

---

## 6) Write Path (When to Log)

Log an `alert_events` row **only after the delivery provider accepts the send**
(`SENT`).

### Required checks before log
- Alert eligibility is validated (Saved Item, visibility, etc.)
- Delivery provider returns success/accepted
- Event details (type, product, prices) are available

### Price data rules
- **PRICE_DROP**: must include `priceAtTrigger` and `previousPrice` if known.
- **BACK_IN_STOCK**: `priceAtTrigger` optional; `previousPrice` optional.
- Currency defaults to `USD` if not provided.

### Provenance rules
- `triggerPriceId` **must** be set when a price row exists (expected for both
  price drop and back-in-stock).
- `sourceId` and `retailerId` must be set when available.
- `alertId` and `watchlistItemId` must be set.

### Fail closed
If eligibility, prices, or delivery state is ambiguous → **do not log**.

---

## 6.1) Alerter Integration (Required)

The current alerter uses a **two‑phase claim/commit** protocol:

1. `claimNotificationSlot(...)`
2. `sendNotification(...)`
3. `commitNotificationSend(...)`
4. `releaseNotificationClaim(...)` on failure

**Alert history logging must integrate into this lifecycle**:

**Required sequence (per notification attempt):**
1. Claim slot
2. Send notification
3. **If send accepted**, write `alert_events` and commit in the **same transaction**
4. If send fails, release claim and **do not** write history

### Required changes
- `sendNotification(...)` **must return** `{ success: boolean; providerMessageId?: string; error?: string }`
  and **must not swallow errors**. If email is disabled (no API key or global disable),
  return `{ success: false, error: 'EMAIL_DISABLED' }`.
- `commitNotificationSend(...)` must accept an optional `alertEvent` payload and
  insert into `alert_events` **within the same transaction** as the commit update.
- If `commitNotificationSend(...)` fails, **do not** write history.

> Rationale: prevents “sent history” from being written when a send did not occur,
> and avoids orphan history rows on crashes between commit and insert.

---

## 6.2) Alert Job Payload Requirements

The alerter must receive **trigger-time data** to avoid races:

**Required fields in AlertJobData:**
- `triggerPriceId` (primary idempotency key)
- `triggeredAt` (ISO string, trigger time)
- `retailerId` and `sourceId` (provenance)
- `priceAtTrigger` and `previousPrice` (for price drop)
- `currency` (default USD if omitted)

If these fields are not in the job payload, the pipeline must be updated to include them.
Do **not** re-query “current” prices at send time to populate history fields.

---

## 7) API: Alert History

### Endpoint
`GET /api/saved-items/history`

### Auth
Required (consumer user).

### Query Params
- `limit` (default `50`, max `100`)
- `cursor` (optional) — **opaque base64** cursor (server‑defined)

### Response (v1)
```json
{
  "history": [
    {
      "id": "evt_...",
      "type": "PRICE_DROP",
      "productId": "prod_...",
      "productName": "Federal 9mm 115gr 100rd",
      "triggeredAt": "2026-02-08T18:45:12Z",
      "metadata": {
        "oldPrice": 24.99,
        "newPrice": 19.99,
        "currency": "USD",
        "retailer": "MidwayUSA"
      }
    }
  ],
  "_meta": {
    "schemaVersion": 1,
    "limit": 50,
    "hasMore": true,
    "nextCursor": "MjAyNi0wMi0wOFQxODo0NToxMlo8fGV2dF8uLi4="
  }
}
```

### Response (BACK_IN_STOCK example)
```json
{
  "history": [
    {
      "id": "evt_...",
      "type": "BACK_IN_STOCK",
      "productId": "prod_...",
      "productName": "Federal 9mm 115gr 100rd",
      "triggeredAt": "2026-02-08T18:45:12Z",
      "metadata": {
        "newPrice": 19.99,
        "currency": "USD",
        "retailer": "MidwayUSA"
      }
    }
  ],
  "_meta": {
    "schemaVersion": 1,
    "limit": 50,
    "hasMore": false,
    "nextCursor": null
  }
}
```

### Cursor contract
- Cursor value is **opaque**. Clients must not parse it.
- Server encodes the internal cursor (currently `triggeredAt|id`) as base64.
- Server may change encoding without breaking clients.

### Schema version contract
- Clients must **ignore unknown fields**.
- If `schemaVersion` is higher than supported, clients must still render
  the fields they understand (no hard failure).

### Query-time filtering
- History should only return events owned by the authenticated user.
- If `retailerId` is present and the retailer is now ineligible/unlisted, the
  API must **redact retailer details and external links** from the response.
  The event itself may remain visible to preserve history.
- **Redaction contract:** `metadata.retailer` is **present but null** when redacted
  (so the UI can consistently check for null and render “Retailer unavailable”).

---

## 8) Migration SQL (Postgres)

```sql
-- CreateTable
CREATE TABLE "alert_events" (
  "id" TEXT NOT NULL,
  "userId" TEXT,
  "watchlistItemId" TEXT,
  "alertId" TEXT,
  "productId" TEXT,
  "retailerId" TEXT,
  "sourceId" TEXT,
  "triggerPriceId" TEXT,
  "eventType" TEXT NOT NULL,
  "triggeredAt" TIMESTAMPTZ NOT NULL,
  "priceAtTrigger" DECIMAL(10,2),
  "previousPrice" DECIMAL(10,2),
  "currency" TEXT NOT NULL DEFAULT 'USD',
  "deliveryChannel" TEXT NOT NULL DEFAULT 'EMAIL',
  "providerMessageId" TEXT,
  "idempotencyKey" TEXT NOT NULL,
  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT "alert_events_pkey" PRIMARY KEY ("id"),
  CONSTRAINT "alert_events_userId_fkey"
    FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE SET NULL,
  CONSTRAINT "alert_events_watchlistItemId_fkey"
    FOREIGN KEY ("watchlistItemId") REFERENCES "watchlist_items"("id") ON DELETE SET NULL,
  CONSTRAINT "alert_events_alertId_fkey"
    FOREIGN KEY ("alertId") REFERENCES "alerts"("id") ON DELETE SET NULL,
  CONSTRAINT "alert_events_productId_fkey"
    FOREIGN KEY ("productId") REFERENCES "products"("id") ON DELETE SET NULL,
  CONSTRAINT "alert_events_retailerId_fkey"
    FOREIGN KEY ("retailerId") REFERENCES "retailers"("id") ON DELETE SET NULL,
  CONSTRAINT "alert_events_sourceId_fkey"
    FOREIGN KEY ("sourceId") REFERENCES "sources"("id") ON DELETE SET NULL,
  CONSTRAINT "alert_events_triggerPriceId_fkey"
    FOREIGN KEY ("triggerPriceId") REFERENCES "prices"("id") ON DELETE SET NULL
);

-- Enums via CHECK constraints (if not using native enums)
ALTER TABLE "alert_events"
  ADD CONSTRAINT "alert_events_event_type_check"
  CHECK ("eventType" IN ('PRICE_DROP', 'BACK_IN_STOCK'));

ALTER TABLE "alert_events"
  ADD CONSTRAINT "alert_events_delivery_channel_check"
  CHECK ("deliveryChannel" IN ('EMAIL'));

ALTER TABLE "alert_events"
  ADD CONSTRAINT "alert_events_currency_check"
  CHECK ("currency" IN ('USD'));

-- Unique idempotency key
CREATE UNIQUE INDEX "alert_events_idempotency_key"
  ON "alert_events"("idempotencyKey");

-- Read path indexes
CREATE INDEX "alert_events_userId_triggeredAt_idx"
  ON "alert_events"("userId", "triggeredAt" DESC);

CREATE INDEX "alert_events_watchlistItemId_triggeredAt_idx"
  ON "alert_events"("watchlistItemId", "triggeredAt" DESC);

CREATE INDEX "alert_events_productId_triggeredAt_idx"
  ON "alert_events"("productId", "triggeredAt" DESC);

CREATE INDEX "alert_events_triggerPriceId_idx"
  ON "alert_events"("triggerPriceId");
```

> Note: IDs are application-generated CUIDs (matches existing patterns).

---

## 9) Prisma Model (for reference)

```prisma
enum AlertEventType {
  PRICE_DROP
  BACK_IN_STOCK
}

enum AlertDeliveryChannel {
  EMAIL
}

model alert_events {
  id               String   @id @default(cuid())
  userId           String?
  watchlistItemId  String?
  alertId          String?
  productId        String?
  retailerId       String?
  sourceId         String?
  triggerPriceId   String?
  eventType        AlertEventType
  triggeredAt      DateTime
  priceAtTrigger   Decimal? @db.Decimal(10, 2)
  previousPrice    Decimal? @db.Decimal(10, 2)
  currency         String   @default("USD")
  deliveryChannel  AlertDeliveryChannel @default(EMAIL)
  providerMessageId String?
  idempotencyKey   String   @unique
  createdAt        DateTime @default(now())

  users            users?           @relation(fields: [userId], references: [id], onDelete: SetNull)
  watchlist_items  watchlist_items? @relation(fields: [watchlistItemId], references: [id], onDelete: SetNull)
  alerts           alerts?          @relation(fields: [alertId], references: [id], onDelete: SetNull)
  products         products?        @relation(fields: [productId], references: [id], onDelete: SetNull)
  retailers        retailers?       @relation(fields: [retailerId], references: [id], onDelete: SetNull)
  sources          sources?         @relation(fields: [sourceId], references: [id], onDelete: SetNull)
  prices           prices?          @relation(fields: [triggerPriceId], references: [id], onDelete: SetNull)

  @@index([userId, triggeredAt])
  @@index([watchlistItemId, triggeredAt])
  @@index([productId, triggeredAt])
  @@index([triggerPriceId])
}
```

**Schema note:** Add the reverse relation fields to parent models
(`users`, `watchlist_items`, `alerts`, `products`, `retailers`, `sources`,
`prices`) to avoid Prisma relation drift.

---

## 10) UI Expectations (Issue #88)

`/dashboard/alerts` must render:
- Product name + link
- Event type (price drop / back-in-stock)
- Triggered date
- Price change details (old → new, when available)
- Cursor pagination (infinite scroll or “Load more”)
- Empty state: “No alerts yet — we’ll notify you when prices drop on your saved items.”
- Loading state: skeleton rows or spinner
- Error state: retry button + conservative error message
- Timestamp display: use relative time for < 48h, absolute date/time otherwise
- Missing product: show “Product unavailable” and disable link
- Event type visual distinction: show a badge/icon per type (PRICE_DROP vs BACK_IN_STOCK)
- Superseded product: if a product has `supersededById`, link to the superseding
  product and display “Updated listing” (do not show a 404).

> API requirement: history response should resolve superseded products and return
> the **current** productId + name for linking. If the original differs, include
> `metadata.originalProductId`.

---

## 11) Tests (Minimal)

### DB
- Insert with same `idempotencyKey` does not duplicate.
- Deleting user/watchlist item/product sets FK to NULL (history remains).

### API
- Auth required (401 if unauthenticated).
- User can only see their own history.
- Cursor pagination returns correct `hasMore` and `nextCursor`.
- Invalid `limit` or malformed `cursor` returns 400.

### Alert pipeline (when implemented)
- Logging occurs only after email accepted.
- Retry does not create duplicate history row.
- Concurrent send attempts do not create duplicate history rows.

### ADR-005 guardrail
- If retailer is now ineligible, response redacts retailer name/link.

### Suppression cases
- No history row is written when:
  - alerts disabled on item
  - watchlist item soft-deleted
  - cooldown/rate limit suppression
  - no visible retailer price
  - global email disabled (no RESEND_API_KEY)

---

## 12) Open Questions (Resolved Here)

- **Do we log failed sends?**  
  **No**. Only log when provider accepts. Fail closed.

- **Should history be pruned?**  
  Not in v1. Retention can be added later without breaking API.

- **Should we hide history if a retailer becomes ineligible later?**  
  We keep the event but redact retailer details and links.

- **Do price corrections retroactively affect alert history?**  
  **No** in v1. Alert history reflects the state at trigger time. Retroactive
  price corrections do not modify or hide historical events.

- **Do suppressed alerts hide historical events?**  
  **No**. Suppression prevents future alerts only; previously sent events remain
  visible in history.

---

## 13) Observability (Required)

Emit metrics at the alert logging boundary:
- `alert_events_inserted` (count)
- `alert_events_deduped` (count of conflict‑skipped inserts)
- `alert_events_insert_failed` (count)
- `alert_events_rate` (events/hour by type)

Alert on:
- sustained drop to zero events when alerts are expected (ops‑configured baseline)
- elevated insert failures

---

## 14) Acceptance Criteria

- [ ] Migration creates `alert_events` table with indexes and unique idempotency key.
- [ ] `triggerPriceId` and `sourceId` are stored when available.
- [ ] Alert pipeline writes a history row **only after successful send**.
- [ ] `GET /api/saved-items/history` returns user‑scoped, cursor‑paginated history.
- [ ] Retailer details are redacted if retailer becomes ineligible.
- [ ] UI renders product name, type, triggered date, and price change details.
- [ ] No duplicate history rows under retry or concurrent workers.
- [ ] Remove `execution_logs` mining from `getAlertHistory()` in `apps/api/src/services/saved-items.ts`.
- [ ] Cursor is opaque base64 and treated as such by clients.
- [ ] Superseded products resolve to the current product in API/UI.
- [ ] Orphaned history rows (userId NULL) are purged after 30 days.
